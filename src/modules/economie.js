const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const Stats = require('../src/database/models/statsModel');
const Economie = require('../src/database/models/economieModel');
const Item = require('../src/database/models/itemModel');
const Marketplace = require('../src/database/models/marketplaceModel');
const Inventaire = require('../src/database/models/inventaireModel')
const Equipement = require('../src/database/models/equipementModel');

const { createSuccessEmbed, createErrorEmbed, createBalanceEmbed } = require('../src/utils/embeds');
const { modifierSolde, deviseLabels } = require('../src/utils/devise');
const { isAdmin } = require('../src/utils/permissions');
const parseStats = require('../src/utils/parseStats');

module.exports = {
    commands: [
        
        {
            data: new SlashCommandBuilder()
    .setName('ajoute_devise')
    .setDescription("Ajoute une certaine quantit√© de monnaie √† l'utilisateur sp√©cifi√©. ‚úÖ")
    .addUserOption(option =>
      option.setName('utilisateur')
        .setDescription("L'utilisateur √† qui ajouter la monnaie")
        .setRequired(true))
    .addStringOption(option =>
      option.setName('monnaie')
        .setDescription('Type de monnaie √† ajouter')
        .setRequired(true)
        .addChoices(
          { name: '√âcus', value: 'ecus' },
          { name: 'Cristaux Noirs', value: 'cristaux' },
          { name: 'Points de Fid√©lit√©', value: 'points' }
        ))
    .addIntegerOption(option =>
      option.setName('montant')
        .setDescription('Le montant √† ajouter')
        .setRequired(true)),

  async execute(interaction) {
    if (!isAdmin(interaction.member)) {
      return interaction.reply({
        embeds: [createErrorEmbed('Erreur ‚ùå', "Tu n'as pas les permissions n√©cessaires pour utiliser cette commande.")],
        ephemeral: true
      });
    }

    const user = interaction.options.getUser('utilisateur');
    const monnaie = interaction.options.getString('monnaie');
    const montant = interaction.options.getInteger('montant');

    if (montant <= 0) {
      return interaction.reply({
        embeds: [createErrorEmbed('Erreur ‚ùå', "Le montant doit √™tre sup√©rieur √† z√©ro.")],
        ephemeral: true
      });
    }

    let userEconomie = await Economie.findOne({ userId: user.id });
    if (!userEconomie) {
      userEconomie = new Economie({ userId: user.id });
    }

    modifierSolde(userEconomie, monnaie, montant);
    await userEconomie.save();

    const deviseNom = deviseLabels[monnaie] || monnaie;

    return interaction.reply({
      embeds: [
        createSuccessEmbed(
          'Succ√®s ‚úÖ',
          `${montant} ${deviseNom} ont √©t√© ajout√©s au solde de ${user.username}.`,
          [
            { name: '√âcus üí∞', value: `${userEconomie.ecus}`, inline: true },
            { name: 'Cristaux Noirs üîÆ', value: `${userEconomie.cristauxNoirs}`, inline: true },
            { name: 'Points de Fid√©lit√© ‚≠ê', value: `${userEconomie.pointsFidelite}`, inline: true }
          ]
        )
      ]
    });
  }
},

        
        {
            data: new SlashCommandBuilder()
    .setName('enleve_devise')
    .setDescription("Enl√®ve une certaine quantit√© de monnaie √† l'utilisateur sp√©cifi√©. ‚ùå")
    .addUserOption(option =>
      option.setName('utilisateur')
        .setDescription("L'utilisateur √† qui enlever la monnaie")
        .setRequired(true))
    .addStringOption(option =>
      option.setName('monnaie')
        .setDescription('Type de monnaie √† enlever')
        .setRequired(true)
        .addChoices(
          { name: '√âcus', value: 'ecus' },
          { name: 'Cristaux Noirs', value: 'cristaux' },
          { name: 'Points de Fid√©lit√©', value: 'points' }
        ))
    .addIntegerOption(option =>
      option.setName('montant')
        .setDescription('Le montant √† enlever')
        .setRequired(true)),

  async execute(interaction) {
    if (!isAdmin(interaction.member)) {
      return interaction.reply({
        embeds: [createErrorEmbed('Erreur ‚ùå', "Tu n'as pas les permissions n√©cessaires pour utiliser cette commande.")],
        ephemeral: true
      });
    }

    const user = interaction.options.getUser('utilisateur');
    const monnaie = interaction.options.getString('monnaie');
    const montant = interaction.options.getInteger('montant');

    if (montant <= 0) {
      return interaction.reply({
        embeds: [createErrorEmbed('Erreur ‚ùå', "Le montant doit √™tre sup√©rieur √† z√©ro.")],
        ephemeral: true
      });
    }

    const userEconomie = await Economie.findOne({ userId: user.id });
    if (!userEconomie) {
      return interaction.reply({
        embeds: [createErrorEmbed('Erreur ‚ùå', "L'utilisateur n'a pas encore de compte √©conomique.")],
        ephemeral: true
      });
    }

    const deviseNom = deviseLabels[monnaie] || monnaie;
    let soldeActuel;

    switch (monnaie) {
      case 'ecus':
        soldeActuel = userEconomie.ecus;
        if (soldeActuel < montant) {
          return interaction.reply({
            embeds: [createErrorEmbed('Erreur ‚ùå', `${user.username} n'a pas assez d'√âcus pour cette op√©ration.`)],
            ephemeral: true
          });
        }
        userEconomie.ecus -= montant;
        break;

      case 'cristaux':
        soldeActuel = userEconomie.cristauxNoirs;
        if (soldeActuel < montant) {
          return interaction.reply({
            embeds: [createErrorEmbed('Erreur ‚ùå', `${user.username} n'a pas assez de Cristaux Noirs pour cette op√©ration.`)],
            ephemeral: true
          });
        }
        userEconomie.cristauxNoirs -= montant;
        break;

      case 'points':
        soldeActuel = userEconomie.pointsFidelite;
        if (soldeActuel < montant) {
          return interaction.reply({
            embeds: [createErrorEmbed('Erreur ‚ùå', `${user.username} n'a pas assez de Points de Fid√©lit√© pour cette op√©ration.`)],
            ephemeral: true
          });
        }
        userEconomie.pointsFidelite -= montant;
        break;
    }

    await userEconomie.save();

    return interaction.reply({
      embeds: [
        createSuccessEmbed(
          'Succ√®s ‚úÖ',
          `${montant} ${deviseNom} ont √©t√© retir√©s au solde de ${user.username}.`,
          [
            { name: '√âcus üí∞', value: `${userEconomie.ecus}`, inline: true },
            { name: 'Cristaux Noirs üîÆ', value: `${userEconomie.cristauxNoirs}`, inline: true },
            { name: 'Points de Fid√©lit√© ‚≠ê', value: `${userEconomie.pointsFidelite}`, inline: true }
          ]
        )
      ]
    });
  }
},

        
        {
            data: new SlashCommandBuilder()
    .setName('solde')
    .setDescription('V√©rifie ton solde √©conomique. üí≥'),

  async execute(interaction) {
    const userId = interaction.user.id;
    const username = interaction.user.username;

    let userEconomie = await Economie.findOne({ userId });

    if (!userEconomie) {
      userEconomie = new Economie({ userId });
      await userEconomie.save();

      return interaction.reply({
        embeds: [
          createSuccessEmbed(
            'Bienvenue ! üëã',
            "Tu n'avais pas de solde, je viens de te cr√©er un compte √©conomique."
          )
        ]
      });
    }

    return interaction.reply({
      embeds: [createBalanceEmbed(username, userEconomie)]
    });
  }
},
        {
            data: new SlashCommandBuilder()
    .setName('cree_item')
    .setDescription("Cr√©e un nouvel article dans la boutique. üõí")
    .addStringOption(option =>
      option.setName('nom').setDescription("Nom de l'article").setRequired(true))
    .addStringOption(option =>
      option.setName('description').setDescription("Description de l'article").setRequired(true))
    .addIntegerOption(option =>
      option.setName('prix').setDescription("Prix de l'article").setRequired(true))
    .addStringOption(option =>
      option.setName('devise').setDescription("Devise utilis√©e pour l'achat").setRequired(true)
        .addChoices(
          { name: '√âcus üí∞', value: 'ecus' },
          { name: 'Cristaux Noirs üîÆ', value: 'cristaux' },
          { name: 'Points de Fid√©lit√© ‚≠ê', value: 'points' }
        ))
    .addStringOption(option =>
      option.setName('rarete').setDescription("Raret√© de l'article").setRequired(true)
        .addChoices(
          { name: 'Commun', value: 'Commun' },
          { name: 'Rare', value: 'Rare' },
          { name: '√âpique', value: '√âpique' },
          { name: 'L√©gendaire', value: 'L√©gendaire' }
        ))
    .addBooleanOption(option =>
      option.setName('equipable').setDescription("L'article est-il √©quipable ?").setRequired(true))
    .addIntegerOption(option =>
      option.setName('stock').setDescription("Quantit√© en stock").setRequired(true))
    .addStringOption(option =>
      option.setName('categorie').setDescription("Cat√©gorie de l'article").setRequired(true)
        .addChoices(
          { name: 'Casque ü™ñ', value: 'casque' },
          { name: 'Cuirasse üõ°Ô∏è', value: 'cuirasse' },
          { name: 'Gantelet üß§', value: 'gantelet' },
          { name: 'Gr√®ve ü¶µ', value: 'greve' },
          { name: 'Solerets üë¢', value: 'solerets' },
          { name: '√âpaulettes üèãÔ∏è', value: 'epaulettes' },
          { name: 'Cape üß•', value: 'cape' },
          { name: 'Manchettes üéΩ', value: 'manchettes' },
          { name: 'Anneaux üíç', value: 'anneaux' },
          { name: 'Pendentifs üìø', value: 'pendentifs' },
          { name: 'Arme D üó°Ô∏è', value: 'arme D' },
          { name: 'Arme G üõ°Ô∏è', value: 'arme G' }
        ))
    .addStringOption(option =>
      option.setName('boutique').setDescription("Boutique de destination").setRequired(true)
        .addChoices(
          { name: 'Boutique üè™', value: 'boutique' },
          { name: 'Dark Boutique üåë', value: 'dark_boutique' },
          { name: 'Boutique VIP üíé', value: 'boutique_vip' }
        ))
    .addStringOption(option =>
      option.setName('image').setDescription("URL de l'image (requis pour la boutique VIP)").setRequired(false))
    .addStringOption(option =>
      option.setName('bonus').setDescription("Bonus des stats (ex: force:10)").setRequired(false))
    .addStringOption(option =>
      option.setName('malus').setDescription("Malus des stats (ex: force:-10)").setRequired(false)),

  async execute(interaction) {
    if (!isAdmin(interaction.member)) {
      return interaction.reply({
        embeds: [createErrorEmbed("Acc√®s refus√© üö´", "Vous n'avez pas la permission d'utiliser cette commande.")],
        ephemeral: true
      });
    }

    const bonus = parseStats(interaction.options.getString('bonus'));
    const malus = parseStats(interaction.options.getString('malus'));

    const statsList = ['force', 'agilite', 'vitesse', 'intelligence', 'dexterite', 'vitalite', 'charisme', 'chance'];
    
    const stats = {};

    statsList.forEach(stat => {
      stats[stat] = {
        bonus: bonus[stat] || 0,
        malus: malus[stat] || 0
      };
    });

    const itemData = {
      name: interaction.options.getString('nom'),
      description: interaction.options.getString('description'),
      price: interaction.options.getInteger('prix'),
      devise: interaction.options.getString('devise'),
      rarete: interaction.options.getString('rarete'),
      equipable: interaction.options.getBoolean('equipable'),
      stock: interaction.options.getInteger('stock'),
      categorie: interaction.options.getString('categorie'),
      boutique: interaction.options.getString('boutique'),
      image: interaction.options.getString('image'),
      stats
    };

    try {
      const nouvelItem = new Item(itemData);
      await nouvelItem.save();

      const fields = [
        { name: 'Prix', value: `${itemData.price} ${itemData.devise}`, inline: true },
        { name: 'Raret√©', value: itemData.rarete, inline: true },
        { name: '√âquipable', value: itemData.equipable ? 'Oui ‚úÖ' : 'Non ‚ùå', inline: true },
        { name: 'Stock', value: `${itemData.stock}`, inline: true },
        { name: 'Cat√©gorie', value: itemData.categorie, inline: true },
        { name: 'Boutique', value: itemData.boutique, inline: true },
        ...statsList.map(stat => ({
          name: `${stat.charAt(0).toUpperCase() + stat.slice(1)} üìä`,
          value: `Bonus: ${itemData.stats[stat].bonus} | Malus: ${itemData.stats[stat].malus}`,
          inline: true
        }))
      ];

      const embed = createSuccessEmbed(`‚úÖ Article cr√©√© : ${itemData.name}`, itemData.description, fields);

      if (itemData.image) {
        embed.setImage(itemData.image);
      }

      await interaction.reply({ embeds: [embed] });

    } catch (error) {
      console.error(error);
      await interaction.reply({
        embeds: [createErrorEmbed("‚ùå Erreur", "Une erreur est survenue lors de la cr√©ation de l'article.")],
        ephemeral: true
      });
    }
  }
},

{
    data: new SlashCommandBuilder()
        .setName('voir_boutique')
        .setDescription('Affiche tous les articles d‚Äôune boutique sp√©cifique üõí')
        .addStringOption(option =>
            option.setName('boutique')
                .setDescription("S√©lectionnez la boutique √† afficher üè¨")
                .setRequired(true)
                .addChoices(
                    { name: 'Boutique Standard üè™', value: 'boutique' },
                    { name: 'Dark Boutique üåë', value: 'dark_boutique' },
                    { name: 'Boutique VIP üíé', value: 'boutique_vip' }
                )
        ),

    async execute(interaction) {
        await interaction.deferReply(); 

        try {
            const boutique = interaction.options.getString('boutique');

            
            const items = await Item.find({ boutique });

            if (!items || items.length === 0) {
                return interaction.editReply({ content: '‚ùå Aucun article disponible dans cette boutique.' });
            }

            
            const boutiqueColors = {
                boutique: 0x0099FF, 
                dark_boutique: 0x990000, 
                boutique_vip: 0xFFD700 
            };

            
            const embed = new EmbedBuilder()
                .setColor(boutiqueColors[boutique])
                .setTitle(`üõí Articles de la ${boutique === 'dark_boutique' ? 'Dark Boutique üåë' : boutique === 'boutique_vip' ? 'Boutique VIP üíé' : 'Boutique Standard üè™'}`)
                .setDescription("Voici la liste des articles disponibles dans cette boutique :")
                .setTimestamp()
                .setFooter({ text: 'Syst√®me √©conomique du bot' });

            
            items.forEach(item => {
                embed.addFields({
                    name: `**${item.name}** - üí∞ ${item.price} ${item.devise}`,
                    value: `üìú ${item.description}\nüõí **Stock** : ${item.stock} | üîÆ **Raret√©** : ${item.rarete}`,
                    inline: false
                });
            });

            return interaction.editReply({ embeds: [embed] });

        } catch (error) {
            console.error("Erreur lors de l'ex√©cution de la commande /voir_boutique :", error);
            return interaction.editReply({ content: '‚ùå Une erreur est survenue, r√©essayez plus tard.' });
        }
    }
},
{
    data: new SlashCommandBuilder()
    .setName('acheter')
    .setDescription('Ach√®te un article dans la boutique üõçÔ∏è')
    .addStringOption(option =>
      option.setName('nom').setDescription("Nom de l'article √† acheter").setRequired(true))
    .addIntegerOption(option =>
      option.setName('quantite').setDescription("Quantit√© souhait√©e").setRequired(true)),

  async execute(interaction) {
    await interaction.deferReply();

    const userId = interaction.user.id;
    const username = interaction.user.username;
    const itemName = interaction.options.getString('nom');
    const quantity = interaction.options.getInteger('quantite');

    if (quantity <= 0) {
      return interaction.editReply({
        embeds: [createErrorEmbed("‚ùå Quantit√© invalide", "La quantit√© doit √™tre sup√©rieure √† z√©ro.")]
      });
    }


    const item = await Item.findOne({ name: itemName });
    if (!item) {
      return interaction.editReply({
        embeds: [createErrorEmbed("‚ùå Article introuvable", "Cet article n‚Äôexiste pas dans la boutique.")]
      });
    }


    const userEconomie = await Economie.findOne({ userId });
    const devise = item.devise;
    const deviseNom = deviseLabels[devise] || devise;
    const totalPrix = item.price * quantity;

    if (!userEconomie || userEconomie[devise] < totalPrix) {
      return interaction.editReply({
        embeds: [createErrorEmbed("‚ùå Fonds insuffisants", `Tu n'as pas assez de ${deviseNom} pour acheter cet article.`)]
      });
    }


    if (item.stock < quantity) {
      return interaction.editReply({
        embeds: [createErrorEmbed("‚ùå Stock insuffisant", `Stock disponible : ${item.stock}`)]
      });
    }

    
    userEconomie[devise] -= totalPrix;
    await userEconomie.save();

    
    item.stock -= quantity;
    await item.save();

    
    let userInventaire = await Inventaire.findOne({ userId });
    if (!userInventaire) {
      userInventaire = new Inventaire({ userId, items: [] });
    }


    const existingItem = userInventaire.items.find(i => i.itemId.equals(item._id));
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      userInventaire.items.push({ itemId: item._id, quantity });
    }

    await userInventaire.save();

    
    return interaction.editReply({
      embeds: [
        createSuccessEmbed(
          'üõçÔ∏è Achat r√©ussi !',
          `Tu as achet√© **${quantity}x ${item.name}** pour **${totalPrix} ${deviseNom}**.`
        )
      ]
    });
  }
},

{
    data: new SlashCommandBuilder()
        .setName('inventaire')
        .setDescription("Affiche ton inventaire üì¶")
        .addUserOption(option =>
            option.setName('utilisateur')
                .setDescription("Voir l'inventaire d'un autre utilisateur")
                .setRequired(false)),

    async execute(interaction) {
        const user = interaction.options.getUser('utilisateur') || interaction.user;
        const userId = user.id;

        try {
            
            let userInventaire = await Inventaire.findOne({ userId }).populate('items.itemId');

            if (!userInventaire || userInventaire.items.length === 0) {
                return interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(0xFF0000)
                            .setTitle(`üì¶ Inventaire de ${user.username}`)
                            .setDescription("‚ùå Ton inventaire est vide !")
                            .setFooter({ text: "Syst√®me √©conomique du bot" })
                            .setTimestamp()
                    ],
                    ephemeral: true
                });
            }

            
            const categoryEmojis = {
                casque: "ü™ñ",
                cuirasse: "üõ°Ô∏è",
                gantelet: "üß§",
                greve: "ü¶µ",
                solerets: "üë¢",
                epaulettes: "üèãÔ∏è",
                cape: "üß•",
                manchettes: "üéΩ",
                anneaux: "üíç",
                pendentifs: "üìø",
                "arme D": "üó°Ô∏è",
                "arme G": "üõ°Ô∏è"
            };

            
            const currencyEmojis = {
                ecus: "üí∞",
                cristaux: "üîÆ",
                points: "‚≠ê"
            };

            
            const fields = userInventaire.items.map(i => {
                const item = i.itemId;
                const categoryEmoji = categoryEmojis[item.categorie] || "üì¶";
                const currencyEmoji = currencyEmojis[item.devise] || "üíµ";

                return {
                    name: `${categoryEmoji} ${item.name}`,
                    value: `üìú **${item.description}**\nüî¢ **Quantit√©**: ${i.quantity}\nüí∞ **Valeur**: ${item.price} ${currencyEmoji}`,
                    inline: false
                };
            });

            
            const embeds = [];
            for (let i = 0; i < fields.length; i += 25) {
                const embed = new EmbedBuilder()
                    .setColor(0x0099FF)
                    .setTitle(`üì¶ Inventaire de ${user.username}`)
                    .setDescription("Voici les objets que tu poss√®des :")
                    .addFields(fields.slice(i, i + 25))
                    .setFooter({ text: "Syst√®me √©conomique du bot" })
                    .setTimestamp();
                embeds.push(embed);
            }

            return interaction.reply({ embeds });

        } catch (error) {
            console.error(error);
            return interaction.reply({
                content: "‚ùå Une erreur est survenue lors de la r√©cup√©ration de l'inventaire."});
        }
    }
},

{
  data: new SlashCommandBuilder()
  .setName('revendre')
  .setDescription("Revends un objet de ton inventaire pour de la monnaie üí∞")
  .addStringOption(option =>
    option.setName('objet')
      .setDescription("Nom de l'objet √† revendre üì¶")
      .setRequired(true)
  ),

async execute(interaction) {
  const userId = interaction.user.id;
  const username = interaction.user.username;
  const itemName = interaction.options.getString('objet');

  try {
    const item = await Item.findOne({ name: { $regex: new RegExp(`^${itemName}$`, 'i') } });
    if (!item) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Objet introuvable", `L'objet **${itemName}** n'existe pas.`)],
        ephemeral: true
      });
    }

    const userInventaire = await Inventaire.findOne({ userId });
    if (!userInventaire || !userInventaire.items.some(i => i.itemId.equals(item._id))) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Vente impossible", `Tu ne poss√®des pas **${item.name}** dans ton inventaire.`)],
        ephemeral: true
      });
    }

    const resaleValue = Math.floor(item.price * 0.5);
    const deviseNom = deviseLabels[item.devise] || item.devise;

    let userEconomie = await Economie.findOne({ userId });
    if (!userEconomie) {
      userEconomie = new Economie({ userId, ecus: 0, cristauxNoirs: 0, pointsFidelite: 0 });
    }

    userEconomie[item.devise] += resaleValue;
    await userEconomie.save();

    userInventaire.items = userInventaire.items.filter(i => !i.itemId.equals(item._id));
    await userInventaire.save();

    const categoryEmojis = {
      casque: "ü™ñ", cuirasse: "üõ°Ô∏è", gantelet: "üß§", greve: "ü¶µ", solerets: "üë¢",
      epaulettes: "üèãÔ∏è", cape: "üß•", manchettes: "üéΩ", anneaux: "üíç", pendentifs: "üìø",
      "arme D": "üó°Ô∏è", "arme G": "üõ°Ô∏è"
    };
    const itemEmoji = categoryEmojis[item.categorie] || "üì¶";

    const embed = createSuccessEmbed(
      "‚úÖ Vente r√©ussie !",
      `Tu as vendu **${itemEmoji} ${item.name}** pour **${resaleValue} ${deviseNom}**.`,
      [
        { name: "üìú Description", value: item.description, inline: false },
        { name: "üí∞ Valeur de revente", value: `${resaleValue} ${deviseNom}`, inline: true },
        { name: "üóëÔ∏è Supprim√© de l'inventaire", value: "‚úÖ Oui", inline: true }
      ]
    );

    return interaction.reply({ embeds: [embed] });

  } catch (error) {
    console.error("‚ùå Erreur lors de la vente :", error);
    return interaction.reply({
      embeds: [createErrorEmbed("‚ùå Erreur interne", "Une erreur est survenue lors de la vente.")],
      ephemeral: true
    });
  }
}
},

{
    data: new SlashCommandBuilder()
        .setName('infos_item')
        .setDescription("Affiche les informations d√©taill√©es d'un item üîç")
        .addStringOption(option =>
            option.setName('objet')
                .setDescription("Nom de l'objet √† inspecter üì¶")
                .setRequired(true)),

    async execute(interaction) {
        const itemName = interaction.options.getString('objet');

        try {
            console.log(`üîé Recherche de l'objet : ${itemName}`);

            
            const item = await Item.findOne({ name: { $regex: new RegExp(`^${itemName}$`, 'i') } });

            if (!item) {
                console.log(`‚ùå Objet non trouv√© : ${itemName}`);
                return interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(0xFF0000)
                            .setTitle("‚ùå Objet introuvable !")
                            .setDescription(`L'objet **${itemName}** n'existe pas dans la boutique.`)
                            .setTimestamp()
                            .setFooter({ text: "Syst√®me √©conomique du bot" })
                    ],
                    ephemeral: true
                });
            }

            console.log(`‚úÖ Objet trouv√© : ${item.name}`);

            
            const categoryEmojis = {
                casque: "ü™ñ",
                cuirasse: "üõ°Ô∏è",
                gantelet: "üß§",
                greve: "ü¶µ",
                solerets: "üë¢",
                epaulettes: "üèãÔ∏è",
                cape: "üß•",
                manchettes: "üéΩ",
                anneaux: "üíç",
                pendentifs: "üìø",
                "arme D": "üó°Ô∏è",
                "arme G": "üõ°Ô∏è"
            };

            
            const rarityColors = {
                Commun: 0xA0A0A0,       
                Rare: 0x0084FF,         
                √âpique: 0x800080,       
                L√©gendaire: 0xFFD700    
            };


            const currencyEmojis = {
                ecus: "üí∞",
                cristaux: "üîÆ",
                points: "‚≠ê"
            };

            
            const shopEmojis = {
                boutique: "üè™",
                dark_boutique: "üåë",
                boutique_vip: "üíé"
            };

            
            const itemEmoji = categoryEmojis[item.categorie] || "üì¶";

            
            let statsText = "Aucune statistique.";
            if (item.stats && Object.keys(item.stats).length > 0) {
                statsText = Object.entries(item.stats)
                    .map(([stat, values]) => `**${stat}**: +${values.bonus} | -${values.malus}`)
                    .join("\n");
            }

            
            const embed = new EmbedBuilder()
                .setColor(rarityColors[item.rarete] || 0xFFFFFF)
                .setTitle(`${itemEmoji} **${item.name}**`)
                .setDescription(`üìú **Description** : ${item.description}`)
                .addFields(
                    { name: "üíé Raret√©", value: item.rarete, inline: true },
                    { name: "üí∞ Prix", value: `${item.price} ${currencyEmojis[item.devise] || "üíµ"}`, inline: true },
                    { name: "üì¶ Stock", value: `${item.stock}`, inline: true },
                    { name: "üè¨ Boutique", value: `${shopEmojis[item.boutique] || "üè™"} ${item.boutique}`, inline: true },
                    { name: "üõ°Ô∏è Cat√©gorie", value: `${itemEmoji} ${item.categorie}`, inline: true },
                    { name: "üìä Statistiques", value: statsText, inline: false }
                )
                .setTimestamp()
                .setFooter({ text: "Syst√®me √©conomique du bot" });

            
            if (item.image) {
                embed.setImage(item.image);
            }

            return interaction.reply({ embeds: [embed] });

        } catch (error) {
            console.error(`‚ùå Erreur lors de l'affichage des informations de l'item :`, error);
            return interaction.reply({
                embeds: [
                    new EmbedBuilder()
                        .setColor(0xFF0000)
                        .setTitle("‚ùå Erreur interne")
                        .setDescription("Une erreur est survenue lors de la r√©cup√©ration des informations.")
                        .setTimestamp()
                        .setFooter({ text: "Syst√®me √©conomique du bot" })
                ],
                ephemeral: true
            });
        }
    }
},

{
    data: new SlashCommandBuilder()
        .setName('equiper')
        .setDescription("√âquipe un objet de ton inventaire üì¶")
        .addStringOption(option =>
            option.setName('objet')
                .setDescription("Nom de l'objet √† √©quiper")
                .setRequired(true)),

    async execute(interaction) {
        const userId = interaction.user.id;
        const itemName = interaction.options.getString('objet');

        try {
            
            const item = await Item.findOne({ name: itemName });
            if (!item) {
                return interaction.reply({ content: "‚ùå Cet objet n'existe pas.", ephemeral: true });
            }

            
            if (!item.equipable) {
                return interaction.reply({ content: "‚ùå Cet objet ne peut pas √™tre √©quip√©.", ephemeral: true });
            }

            
            const userInventaire = await Inventaire.findOne({ userId });
            if (!userInventaire) {
                return interaction.reply({ content: "‚ùå Tu ne poss√®des pas d'inventaire.", ephemeral: true });
            }

            
            const itemIndex = userInventaire.items.findIndex(i => i.itemId.equals(item._id));
            if (itemIndex === -1 || userInventaire.items[itemIndex].quantity <= 0) {
                return interaction.reply({ content: "‚ùå Tu ne poss√®des pas cet objet en quantit√© suffisante.", ephemeral: true });
            }

            
            let userEquipement = await Equipement.findOne({ userId });
            if (!userEquipement) {
                userEquipement = new Equipement({ userId, equipement: {} });
            }

            
            const slot = item.categorie; 
            const equipementActuel = userEquipement.equipement[slot];

            
            let userStats = await Stats.findOne({ userId });
            if (!userStats) {
                userStats = new Stats({ userId });
            }

            
            if (equipementActuel) {
                const oldItem = await Item.findById(equipementActuel);
                if (oldItem) {
                    
                    const existingIndex = userInventaire.items.findIndex(i => i.itemId.equals(oldItem._id));
                    if (existingIndex !== -1) {
                        userInventaire.items[existingIndex].quantity += 1; 
                    } else {
                        userInventaire.items.push({ itemId: oldItem._id, quantity: 1 });
                    }
                }
            }

            
            userEquipement.equipement[slot] = item._id;

            
            userInventaire.items[itemIndex].quantity -= 1;
            if (userInventaire.items[itemIndex].quantity <= 0) {
                userInventaire.items.splice(itemIndex, 1); 
            }

            
            await userInventaire.save();
            await userEquipement.save();

            
            const embed = new EmbedBuilder()
                .setColor(0x00FF00)
                .setTitle(`‚úÖ ${interaction.user.username} a √©quip√© ${item.name} !`)
                .setDescription("L'√©quipement a √©t√© mis √† jour avec succ√®s.")
                .addFields(
                    { name: "üìú Description", value: item.description },
                    { name: "üõ°Ô∏è √âquip√© √†", value: slot, inline: true },
                    { name: "üìà Bonus", value: Object.entries(item.stats).map(([stat, values]) => `+${values.bonus} ${stat}`).join("\n") || "Aucun", inline: true },
                    { name: "üìâ Malus", value: Object.entries(item.stats).map(([stat, values]) => `-${values.malus} ${stat}`).join("\n") || "Aucun", inline: true }
                )
                .setTimestamp()
                .setFooter({ text: "Syst√®me d'√©quipement du bot" });

            return interaction.reply({ embeds: [embed] });

        } catch (error) {
            console.error(error);
            return interaction.reply({ content: "‚ùå Une erreur est survenue lors de l'√©quipement.", ephemeral: true });
        }
    }
},

{
    data: new SlashCommandBuilder()
        .setName('desequiper')
        .setDescription("Retire un objet √©quip√© et le remet dans l'inventaire. üõ°Ô∏è")
        .addStringOption(option =>
            option.setName('objet')
                .setDescription("Nom de l'objet √† d√©s√©quiper üì¶")
                .setRequired(true)),

    async execute(interaction) {
        const userId = interaction.user.id;
        const itemName = interaction.options.getString('objet');

        try {
            console.log(`üîé Recherche de l'objet : ${itemName}`);

            
            const item = await Item.findOne({ name: { $regex: new RegExp(`^${itemName}$`, 'i') } });

            if (!item) {
                console.log(`‚ùå Objet non trouv√© : ${itemName}`);
                return interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(0xFF0000)
                            .setTitle("‚ùå Objet introuvable !")
                            .setDescription(`L'objet **${itemName}** n'existe pas.`)
                            .setTimestamp()
                            .setFooter({ text: "Syst√®me d'√©quipement du bot" })
                    ],
                    ephemeral: true
                });
            }

            console.log(`‚úÖ Objet trouv√© : ${item.name} (ID: ${item._id})`);

            
            const userEquipement = await Equipement.findOne({ userId });

            if (!userEquipement) {
                console.log(`‚ùå L'utilisateur n'a aucun √©quipement.`);
                return interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(0xFF0000)
                            .setTitle("‚ùå Impossible de d√©s√©quiper !")
                            .setDescription("Tu n'as aucun √©quipement actif.")
                            .setTimestamp()
                            .setFooter({ text: "Syst√®me d'√©quipement du bot" })
                    ],
                    ephemeral: true
                });
            }


            const itemIdString = item._id.toString();
            const slot = Object.keys(userEquipement.equipement).find(
                key => userEquipement.equipement[key] && userEquipement.equipement[key].toString() === itemIdString
            );

            if (!slot) {
                console.log(`‚ùå L'objet n'est pas √©quip√©.`);
                return interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(0xFF0000)
                            .setTitle("‚ùå Impossible de d√©s√©quiper !")
                            .setDescription(`Tu n'as pas **${item.name}** √©quip√©.`)
                            .setTimestamp()
                            .setFooter({ text: "Syst√®me d'√©quipement du bot" })
                    ],
                    ephemeral: true
                });
            }

            console.log(`‚úÖ Objet trouv√© dans l'emplacement : ${slot}`);


            await Equipement.updateOne(
                { userId },
                { $unset: { [`equipement.${slot}`]: 1 } }
            );

            console.log(`‚úÖ Objet retir√© de l'√©quipement !`);


            let userInventaire = await Inventaire.findOne({ userId });

            if (!userInventaire) {
                userInventaire = new Inventaire({ userId, items: [] });
            }


            const existingItem = userInventaire.items.find(i => i.itemId.equals(item._id));
            if (existingItem) {
                existingItem.quantity += 1;
            } else {
                userInventaire.items.push({ itemId: item._id, quantity: 1 });
            }

            await userInventaire.save();

            console.log(`‚úÖ Objet d√©s√©quip√© et ajout√© √† l'inventaire.`);


            const categoryEmojis = {
                casque: "ü™ñ",
                cuirasse: "üõ°Ô∏è",
                gantelet: "üß§",
                greve: "ü¶µ",
                solerets: "üë¢",
                epaulettes: "üèãÔ∏è",
                cape: "üß•",
                manchettes: "üéΩ",
                anneaux: "üíç",
                pendentifs: "üìø",
                "arme D": "üó°Ô∏è",
                "arme G": "üõ°Ô∏è"
            };


            const itemEmoji = categoryEmojis[item.categorie] || "üì¶";


            const embed = new EmbedBuilder()
                .setColor(0xFFA500)
                .setTitle(`‚úÖ ${interaction.user.username} a d√©s√©quip√© un objet !`)
                .setDescription(`L'objet **${itemEmoji} ${item.name}** a √©t√© retir√© et ajout√© √† ton inventaire.`)
                .addFields(
                    { name: "üìú Description", value: item.description, inline: false },
                    { name: "üõ°Ô∏è Emplacement", value: slot, inline: true },
                    { name: "üîÑ Ajout√© dans l'inventaire", value: "‚úÖ Oui", inline: true }
                )
                .setTimestamp()
                .setFooter({ text: "Syst√®me d'√©quipement du bot" });

            return interaction.reply({ embeds: [embed] });

        } catch (error) {
            console.error(`‚ùå Erreur lors du d√©s√©quipement :`, error);
            return interaction.reply({
                embeds: [
                    new EmbedBuilder()
                        .setColor(0xFF0000)
                        .setTitle("‚ùå Erreur interne")
                        .setDescription("Une erreur est survenue lors du d√©s√©quipement.")
                        .setTimestamp()
                        .setFooter({ text: "Syst√®me d'√©quipement du bot" })
                ],
                ephemeral: true
            });
        }
    }
}, 

{
  data: new SlashCommandBuilder()
  .setName('marketplace')
  .setDescription('Affiche les items disponibles sur le marketplace'),

async execute(interaction) {
  try {
    const itemsEnVente = await Marketplace.find().populate('itemId');

    if (!itemsEnVente.length) {
      return interaction.reply({
        embeds: [createErrorEmbed("üõí Aucun article", "Aucun item n'est disponible sur le marketplace pour le moment.")],
        ephemeral: true
      });
    }

    const embed = createSuccessEmbed(
      'üõí Marketplace - Articles en vente',
      'Voici les articles actuellement disponibles sur le marketplace :'
    );

    itemsEnVente.forEach(vente => {
      embed.addFields({
        name: `üîπ ${vente.itemId.name}`,
        value: `üì¶ Quantit√© : **${vente.quantity}**\nüí∞ Prix : **${vente.price} ${vente.devise}**\nüõí Vendeur : <@${vente.sellerId}>`,
        inline: false
      });
    });

    await interaction.reply({ embeds: [embed] });

  } catch (error) {
    console.error("‚ùå Erreur marketplace :", error);
    await interaction.reply({
      embeds: [createErrorEmbed("‚ùå Erreur interne", "Une erreur est survenue lors de la r√©cup√©ration du marketplace.")],
      ephemeral: true
    });
  }
}
},

{
  data: new SlashCommandBuilder()
  .setName('ajouter-au-marketplace')
  .setDescription("Ajoute un item de votre inventaire au marketplace")
  .addStringOption(option =>
    option.setName('item').setDescription("Nom de l'item √† vendre").setRequired(true))
  .addIntegerOption(option =>
    option.setName('quantite').setDescription("Quantit√© √† vendre").setRequired(true).setMinValue(1))
  .addIntegerOption(option =>
    option.setName('prix').setDescription("Prix de vente").setRequired(true).setMinValue(1))
  .addStringOption(option =>
    option.setName('devise').setDescription("Devise de la vente").setRequired(true)
      .addChoices(
        { name: 'üí∞ √âcus', value: 'ecus' },
        { name: 'üîÆ Cristaux', value: 'cristaux' },
        { name: '‚≠ê Points', value: 'points' }
      )),

async execute(interaction) {
  const userId = interaction.user.id;
  const itemName = interaction.options.getString('item');
  const quantite = interaction.options.getInteger('quantite');
  const prix = interaction.options.getInteger('prix');
  const devise = interaction.options.getString('devise');
  const deviseNom = deviseLabels[devise] || devise;

  try {
    const item = await Item.findOne({ name: itemName });
    if (!item) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Item introuvable", "Cet item n'existe pas.")],
        ephemeral: true
      });
    }

    const inventaire = await Inventaire.findOne({ userId });
    if (!inventaire) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Inventaire vide", "Vous ne poss√©dez aucun inventaire.")],
        ephemeral: true
      });
    }

    const itemIndex = inventaire.items.findIndex(i => i.itemId.toString() === item._id.toString());
    if (itemIndex === -1 || inventaire.items[itemIndex].quantity < quantite) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Quantit√© insuffisante", "Vous n'avez pas assez de cet item en stock.")],
        ephemeral: true
      });
    }

    inventaire.items[itemIndex].quantity -= quantite;
    if (inventaire.items[itemIndex].quantity <= 0) {
      inventaire.items.splice(itemIndex, 1);
    }
    await inventaire.save();

    const vente = new Marketplace({
      sellerId: userId,
      itemId: item._id,
      quantity: quantite,
      price: prix,
      devise
    });
    await vente.save();

    const embed = createSuccessEmbed(
      '‚úÖ Ajout au Marketplace',
      'Votre item a √©t√© ajout√© avec succ√®s au marketplace !',
      [
        { name: 'üì¶ Item', value: `**${item.name}**`, inline: true },
        { name: 'üìä Quantit√©', value: `**${quantite}**`, inline: true },
        { name: 'üí∞ Prix', value: `**${prix} ${deviseNom}**`, inline: true }
      ]
    ).setFooter({ text: 'March√© mis √† jour avec succ√®s !' });

    await interaction.reply({ embeds: [embed] });

  } catch (error) {
    console.error("‚ùå Erreur Marketplace :", error);
    await interaction.reply({
      embeds: [createErrorEmbed("‚ùå Erreur interne", "Une erreur est survenue lors de l'ajout au marketplace.")],
      ephemeral: true
    });
  }
}
},

{
  data: new SlashCommandBuilder()
  .setName('acheter_marketplace')
  .setDescription("üõí Ach√®te un objet depuis le Marketplace")
  .addStringOption(option =>
    option.setName('item').setDescription("Nom de l'item √† acheter").setRequired(true))
  .addIntegerOption(option =>
    option.setName('quantite').setDescription("Quantit√© souhait√©e").setRequired(true).setMinValue(1)),

async execute(interaction) {
  const userId = interaction.user.id;
  const itemName = interaction.options.getString('item');
  const quantiteAchat = interaction.options.getInteger('quantite');

  try {
    const item = await Item.findOne({ name: itemName });
    if (!item) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Introuvable", "Cet item n'existe pas dans la base de donn√©es.")],
        ephemeral: true
      });
    }

    const vente = await Marketplace.findOne({ itemId: item._id }).populate('itemId');
    if (!vente) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Non en vente", "Cet item n'est pas en vente sur le Marketplace.")],
        ephemeral: true
      });
    }

    if (vente.quantity < quantiteAchat) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Stock insuffisant", `Seulement ${vente.quantity} disponible.`)],
        ephemeral: true
      });
    }

    const acheteurEconomie = await Economie.findOne({ userId });
    if (!acheteurEconomie) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Compte requis", "Vous n'avez pas de compte √©conomique.")],
        ephemeral: true
      });
    }

    const totalPrix = vente.price * quantiteAchat;
    const deviseNom = deviseLabels[vente.devise] || vente.devise;

    if (acheteurEconomie[vente.devise] < totalPrix) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Fonds insuffisants", `Vous n'avez pas assez de ${deviseNom} pour cet achat.`)],
        ephemeral: true
      });
    }

    const vendeurEconomie = await Economie.findOne({ userId: vente.sellerId });
    if (!vendeurEconomie) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Vendeur invalide", "Le vendeur n'a pas de compte √©conomique valide.")],
        ephemeral: true
      });
    }

    
    acheteurEconomie[vente.devise] -= totalPrix;
    vendeurEconomie[vente.devise] += totalPrix;
    await acheteurEconomie.save();
    await vendeurEconomie.save();

    
    let acheteurInventaire = await Inventaire.findOne({ userId });
    if (!acheteurInventaire) {
      acheteurInventaire = new Inventaire({ userId, items: [] });
    }

    const itemIndex = acheteurInventaire.items.findIndex(i => i.itemId.equals(item._id));
    if (itemIndex !== -1) {
      acheteurInventaire.items[itemIndex].quantity += quantiteAchat;
    } else {
      acheteurInventaire.items.push({ itemId: item._id, quantity: quantiteAchat });
    }
    await acheteurInventaire.save();

    
    vente.quantity -= quantiteAchat;
    if (vente.quantity <= 0) {
      await Marketplace.findByIdAndDelete(vente._id);
    } else {
      await vente.save();
    }

    const embed = createSuccessEmbed(
      'üõí Achat effectu√© !',
      `Vous avez achet√© **${quantiteAchat}x ${vente.itemId.name}** sur le Marketplace.`,
      [
        { name: 'üí∞ Montant pay√©', value: `${totalPrix} ${deviseNom}`, inline: true },
        { name: 'üì¶ Nouvel Inventaire', value: `L'item a √©t√© ajout√© √† votre inventaire.`, inline: true }
      ]
    ).setFooter({ text: 'Merci pour votre achat sur le Marketplace !' });

    return interaction.reply({ embeds: [embed] });

  } catch (error) {
    console.error("‚ùå Erreur achat marketplace :", error);
    return interaction.reply({
      embeds: [createErrorEmbed("‚ùå Erreur interne", "Une erreur est survenue lors de l'achat.")],
      ephemeral: true
    });
  }
}
},

{
  data: new SlashCommandBuilder()
  .setName('retirer_marketplace')
  .setDescription("Retire un item que vous avez mis en vente sur le marketplace.")
  .addStringOption(option =>
    option.setName('item').setDescription("Nom de l'item √† retirer").setRequired(true)
  ),

async execute(interaction) {
  const userId = interaction.user.id;
  const itemName = interaction.options.getString('item');

  try {
    const item = await Item.findOne({ name: itemName });
    if (!item) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Introuvable", "Cet item n'existe pas.")],
        ephemeral: true
      });
    }

    const vente = await Marketplace.findOne({ itemId: item._id, sellerId: userId });
    if (!vente) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Pas en vente", "Vous n'avez pas mis cet item en vente.")],
        ephemeral: true
      });
    }

    const economie = await Economie.findOne({ userId });
    if (!economie) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Aucun compte", "Vous n'avez pas de compte √©conomique.")],
        ephemeral: true
      });
    }

    const deviseNom = deviseLabels[vente.devise] || vente.devise;
    const cout = vente.price * 2;

    if (economie[vente.devise] < cout) {
      return interaction.reply({
        embeds: [createErrorEmbed("‚ùå Fonds insuffisants", `Il vous faut ${cout} ${deviseNom} pour retirer cette annonce.`)],
        ephemeral: true
      });
    }

    economie[vente.devise] -= cout;
    await economie.save();

    let inventaire = await Inventaire.findOne({ userId });
    if (!inventaire) {
      inventaire = new Inventaire({ userId, items: [] });
    }

    const itemIndex = inventaire.items.findIndex(i => i.itemId.equals(item._id));
    if (itemIndex !== -1) {
      inventaire.items[itemIndex].quantity += vente.quantity;
    } else {
      inventaire.items.push({ itemId: item._id, quantity: vente.quantity });
    }

    await inventaire.save();
    await Marketplace.findByIdAndDelete(vente._id);

    const embed = createSuccessEmbed(
      "‚úÖ Annonce retir√©e du Marketplace",
      `Vous avez retir√© **${item.name}** du marketplace.\nüí∏ Co√ªt de l'op√©ration : **${cout} ${deviseNom}**.`
    );

    return interaction.reply({ embeds: [embed] });

  } catch (error) {
    console.error("‚ùå Erreur retrait marketplace :", error);
    return interaction.reply({
      embeds: [createErrorEmbed("‚ùå Erreur interne", "Une erreur est survenue lors du retrait de l'annonce.")],
      ephemeral: true
    });
  }
}
}

    ]
 }